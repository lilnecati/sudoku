//  SoundManager.swift
//  Sudoku
//
//  Created by Necati Yƒ±ldƒ±rƒ±m on 29.03.2025.
//

import Foundation
import AVFoundation
import SwiftUI
import AudioToolbox  // AudioServices i√ßin

/// Sudoku uygulamasƒ± i√ßin ses efektlerini y√∂neten sƒ±nƒ±f
class SoundManager: ObservableObject {
    // MARK: - Properties
    // Singleton pattern
    static let shared = SoundManager()
    
    // Player nesnelerini √∂nden y√ºkleme i√ßin
    private var tapPlayer: AVAudioPlayer?
    private var numberInputPlayer: AVAudioPlayer?
    private var errorPlayer: AVAudioPlayer?
    private var correctPlayer: AVAudioPlayer?
    private var completionPlayer: AVAudioPlayer?
    private var navigationPlayer: AVAudioPlayer?
    private var erasePlayer: AVAudioPlayer?
    
    // Log ayarƒ± - varsayƒ±lan olarak kapalƒ±
    @AppStorage("isLoggingEnabled") private var isLoggingEnabled: Bool = false
    
    // AppStorage ile entegre ses ayarƒ±
    @AppStorage("enableSoundEffects") private var enableSoundEffects: Bool = true
    
    // Ses seviyesi
    @AppStorage("soundVolume") private var defaultVolume: Double = 0.7 // Varsayƒ±lan ses seviyesi
    
    private var powerManager = PowerSavingManager.shared
    
    private init() {
        log("SoundManager ba≈ülatƒ±lƒ±yor...")
        
        // Audio session ayarlarƒ±
        setupAudioSession()
        
        // Sesleri √∂nceden y√ºkle
        preloadSounds()
        
        log("SoundManager ba≈ülatƒ±ldƒ±")
        
        // Ses seviyesi deƒüi≈üim bildirimini dinle
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleVolumeChange),
            name: NSNotification.Name("SoundVolumeChangedNotification"),
            object: nil
        )
    }
    
    deinit {
        // Uygulama sonlandƒ±ƒüƒ±nda g√∂zlemcileri temizle
        NotificationCenter.default.removeObserver(self)
    }
    
    private func registerForSystemNotifications() {
        // Sistem olaylarƒ±nƒ± dinle
        NotificationCenter.default.addObserver(self, selector: #selector(handleAppDidEnterBackground), name: UIApplication.didEnterBackgroundNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleAppWillEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleAudioSessionInterruption), name: AVAudioSession.interruptionNotification, object: nil)
        NotificationCenter.default.addObserver(self, selector: #selector(handleRouteChange), name: AVAudioSession.routeChangeNotification, object: nil)
    }
    
    @objc private func handleAppDidEnterBackground() {
        log("üì± Uygulama arka plana ge√ßti - ses sistemi devre dƒ±≈üƒ± bƒ±rakƒ±lƒ±yor")
        deactivateAudioSession()
    }
    
    @objc private func handleAppWillEnterForeground() {
        log("üì± Uygulama √∂n plana ge√ßti - ses sistemi yeniden ba≈ülatƒ±lƒ±yor")
        configureAudioSession()
        resetAudioPlayers()
    }
    
    /// Ses kesintileri olduƒüunda √ßaƒürƒ±lƒ±r (√∂rn. telefon aramasƒ±)
    @objc private func handleAudioSessionInterruption(notification: Notification) {
        guard let userInfo = notification.userInfo,
              let typeValue = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt,
              let type = AVAudioSession.InterruptionType(rawValue: typeValue) else {
            return
        }
        
        switch type {
        case .began:
            log("üîá Ses kesintisi ba≈üladƒ± - ses sistemi duraklatƒ±ldƒ±")
            // Ses oynatma i≈ülemini durdur
            
        case .ended:
            guard let optionsValue = userInfo[AVAudioSessionInterruptionOptionKey] as? UInt else { return }
            let options = AVAudioSession.InterruptionOptions(rawValue: optionsValue)
            
            log("üîà Ses kesintisi sona erdi - ses sistemi yeniden ba≈ülatƒ±lƒ±yor")
            
            if options.contains(.shouldResume) {
                // Ses sistemini yeniden aktif et
                configureAudioSession()
            }
            
        @unknown default:
            log("‚ö†Ô∏è Bilinmeyen ses kesintisi durumu")
        }
    }
    
    /// Ses y√∂nlendirme deƒüi≈üiklikleri olduƒüunda √ßaƒürƒ±lƒ±r (kulaklƒ±k vb.)
    @objc private func handleRouteChange(notification: Notification) {
        guard let userInfo = notification.userInfo,
              let reasonValue = userInfo[AVAudioSessionRouteChangeReasonKey] as? UInt,
              let reason = AVAudioSession.RouteChangeReason(rawValue: reasonValue) else {
            return
        }
        
        switch reason {
        case .newDeviceAvailable:
            log("üéß Yeni ses cihazƒ± baƒülandƒ±")
            // √ñrn. kulaklƒ±k takƒ±ldƒ±
            
        case .oldDeviceUnavailable:
            log("üîà Ses cihazƒ± √ßƒ±karƒ±ldƒ± - hoparl√∂re ge√ßildi")
            // √ñrn. kulaklƒ±k √ßƒ±karƒ±ldƒ±
            
        default:
            log("üîÑ Ses y√∂nlendirme deƒüi≈üti: \(reason.rawValue)")
        }
        
        // Ses sistemini g√ºvenli ≈üekilde yeniden yapƒ±landƒ±r
        configureAudioSession()
    }
    
    /// Audio session'ƒ± yapƒ±landƒ±rƒ±r
    private func configureAudioSession() {
        do {
            // Mevcut durumu kontrol et
            let audioSession = AVAudioSession.sharedInstance()
            
            // Ses kategorisini ve modu ayarla - .playback kategorisi .ambient'ten daha g√ºvenilir
            try audioSession.setCategory(.playback, mode: .default, options: [.mixWithOthers])
            
            // Session'ƒ± aktif et
            try audioSession.setActive(true, options: .notifyOthersOnDeactivation)
            
            log("‚úÖ Audio session ba≈üarƒ±yla yapƒ±landƒ±rƒ±ldƒ± (Kategori: playback)")
        } catch {
            logError("Audio session yapƒ±landƒ±rƒ±lamadƒ±: \(error.localizedDescription)")
        }
    }
    
    /// Audio session'ƒ± devre dƒ±≈üƒ± bƒ±rakƒ±r
    private func deactivateAudioSession() {
        do {
            try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
            log("üîá Audio session devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±")
        } catch {
            logError("Audio session devre dƒ±≈üƒ± bƒ±rakƒ±lamadƒ±: \(error.localizedDescription)")
        }
    }
    
    /// Audio session'ƒ± dƒ±≈üarƒ±dan yapƒ±landƒ±rmak i√ßin public metot (ses √ßalmadan)
    func setupAudioSession() {
        let audioSession = AVAudioSession.sharedInstance()
        
        do {
            try audioSession.setCategory(.ambient, mode: .default, options: [.mixWithOthers])
            try audioSession.setActive(true)
            log("‚úÖ Audio session ba≈üarƒ±yla yapƒ±landƒ±rƒ±ldƒ±")
        } catch {
            logError("Audio session yapƒ±landƒ±rma hatasƒ±: \(error.localizedDescription)")
        }
    }
    
    /// T√ºm ses dosyalarƒ±nƒ± y√ºkler
    private func loadSounds() {
        // Ses dosyalarƒ±nƒ± y√ºkle
        log("üîä Ses dosyalarƒ± y√ºkleniyor...")
        
        // T√ºm ses oynatƒ±cƒ±larƒ±nƒ± sƒ±fƒ±rla - memorydeki sesleri temizler
        resetAudioPlayers()
    }
    
    /// T√ºm ses oynatƒ±cƒ±larƒ±nƒ± sƒ±fƒ±rla - memorydeki sesleri temizler
    func resetAudioPlayers() {
        log("üîÑ T√ºm ses oynatƒ±cƒ±larƒ± sƒ±fƒ±rlanƒ±yor...")
        tapPlayer = nil
        numberInputPlayer = nil
        errorPlayer = nil
        correctPlayer = nil
        completionPlayer = nil
        navigationPlayer = nil
        erasePlayer = nil
        
        // T√ºm sesleri tekrar y√ºkle - √∂nbelleƒüe al
        preloadSounds()
    }
    
    // Sƒ±k kullanƒ±lan sesleri √∂nden y√ºkle
    private func preloadSounds() {
        // Ses a√ßƒ±ksa y√ºkle
        if canPlaySound() {
            log("üîä Ses dosyalarƒ± √∂nceden y√ºkleniyor...")
            
            // Rakam sesi
            numberInputPlayer = loadSound(named: "number_tap", ofType: "wav")
            
            // Silme sesi √∂nbelleƒüe al
            erasePlayer = loadSound(named: "erase", ofType: "wav")
            if erasePlayer == nil {
                log("‚ö†Ô∏è erase.wav y√ºklenemedi, silme i≈üleminde tap sesi kullanƒ±lacak")
                erasePlayer = loadSound(named: "tap", ofType: "wav")
            }
            
            // Doƒüru/yanlƒ±≈ü sesleri
            errorPlayer = loadSound(named: "error", ofType: "wav")
            correctPlayer = loadSound(named: "correct", ofType: "mp3") ?? loadSound(named: "correct", ofType: "wav")
            
            // Biti≈ü sesi
            completionPlayer = loadSound(named: "completion", ofType: "wav")
            
            // Navigasyon sesi olarak tap kullan
            navigationPlayer = loadSound(named: "tap", ofType: "wav")
            
            log("‚úÖ Ses dosyalarƒ± y√ºklendi")
        } else {
            log("‚ö†Ô∏è Ses kapalƒ± olduƒüu i√ßin √∂nden y√ºkleme yapƒ±lmadƒ±")
        }
    }
    
    /// Belirtilen isimli ses dosyasƒ±nƒ± y√ºkler
    func loadSound(named name: String, ofType type: String) -> AVAudioPlayer? {
        log("üîä loadSound √ßaƒürƒ±ldƒ±: \(name).\(type)")
        do {
            let result = try createAudioPlayer(named: name, extension: type)
            log("‚úÖ Ses y√ºklendi: \(name).\(type) - URL: \(result.url?.lastPathComponent ?? "bilinmeyen")")
            return result
        } catch {
            logError("Ses dosyasƒ± y√ºklenirken hata: \(name).\(type) - \(error.localizedDescription)")
            return nil
        }
    }
    
    /// Farklƒ± yollarƒ± ve uzantƒ±larƒ± deneyen daha g√ºvenli bir ses dosyasƒ± y√ºkleme metodu
    private func createAudioPlayer(named name: String, extension fileExt: String) throws -> AVAudioPlayer {
        // Hem Resources/Sounds/ hem de k√∂k dizini kontrol et
        let paths = [
            "Resources/Sounds/\(name)",  // Resources/Sounds altƒ±nda
            "Sounds/\(name)",           // Sounds klas√∂r√ºnde (farklƒ± dizin yapƒ±sƒ± i√ßin)
            name                        // K√∂k dizinde
        ]
        
        // Uzantƒ± alternatifleri - √∂nce belirtilen, sonra alternatif
        var extensions = [fileExt]
        if fileExt == "mp3" {
            extensions.append("wav")
        } else if fileExt == "wav" {
            extensions.append("mp3")
        }
        
        // T√ºm yollarƒ± ve uzantƒ±larƒ± dene
        for path in paths {
            for ext in extensions {
                // URL'den y√ºklemeyi dene
                if let url = Bundle.main.url(forResource: path, withExtension: ext) {
                    do {
                        let fileExists = FileManager.default.fileExists(atPath: url.path)
                        if fileExists {
                            log("‚úÖ Ses dosyasƒ± bulundu: \(path).\(ext)")
                            
                            // Format tespiti
                            let data = try Data(contentsOf: url)
                            let hexSignature = data.prefix(4).map { String(format: "%02X", $0) }.joined()
                            
                            // Format bazlƒ± fileTypeHint se√ßimi
                            var fileTypeHint: String? = nil
                            if hexSignature.hasPrefix("5249") {  // "RIFF" (WAV)
                                fileTypeHint = AVFileType.wav.rawValue
                                log("ÔøΩÔøΩ Format: WAV (RIFF) algƒ±landƒ±")
                            } else if hexSignature.hasPrefix("4944") || hexSignature.hasPrefix("FFFA") || hexSignature.hasPrefix("FFFB") {
                                fileTypeHint = AVFileType.mp3.rawValue
                                log("üîÑ Format: MP3 algƒ±landƒ±")
                            }
                            
                            // Veriyi ve doƒüru format bilgisini kullanarak oynatƒ±cƒ± olu≈ütur
                            do {
                                let player = try AVAudioPlayer(data: data, fileTypeHint: fileTypeHint)
                                player.prepareToPlay()
                                player.volume = Float(defaultVolume)
                                log("‚úÖ Ses oynatƒ±cƒ± ba≈üarƒ±yla olu≈üturuldu: \(path).\(ext)")
                                return player
                            } catch {
                                logError("AVAudioPlayer olu≈üturulamadƒ±: \(error.localizedDescription)")
                                // Diƒüer uzantƒ± veya yol ile devam et
                            }
                        }
                    } catch {
                        logError("\(path).\(ext) y√ºklenirken hata: \(error.localizedDescription)")
                    }
                }
            }
        }
        
        // Hi√ßbir ≈üekilde y√ºklenemedi, hata fƒ±rlat
        logError("Hi√ßbir ≈üekilde y√ºklenemedi: \(name).\(fileExt)")
        throw NSError(domain: "SoundManager", 
                     code: 1001, 
                     userInfo: [NSLocalizedDescriptionKey: "Ses dosyasƒ± bulunamadƒ± veya y√ºklenemedi: \(name).\(fileExt)"])
    }
    
    /// Ses kaynaklarƒ± kontrol etme - debug ama√ßlƒ±
    func checkSoundResources() {
        log("üîç T√úM SES KAYNAKLARI KONTROL EDƒ∞Lƒ∞YOR")
        
        // Uygulama i√ßinde bulunan t√ºm ses dosyalarƒ±nƒ± bul
        let fileManager = FileManager.default
        guard let bundleURL = Bundle.main.resourceURL else {
            log("‚ùå Bundle URL bulunamadƒ±")
            return
        }
        
        // Sesler i√ßin bakƒ±lacak alanlar
        let extensions = ["wav", "mp3"]
        let searchPaths = [
            bundleURL.path,
            bundleURL.appendingPathComponent("Sounds").path,
            bundleURL.appendingPathComponent("Resources").path,
            bundleURL.appendingPathComponent("Resources/Sounds").path
        ]
        
        log("üîç Arama yapƒ±lacak yollar: \(searchPaths)")
        
        // T√ºm dizinleri dola≈ü
        for path in searchPaths {
            if fileManager.fileExists(atPath: path) {
                log("‚úÖ Var olan dizin: \(path)")
                do {
                    // Bu dizindeki t√ºm dosyalarƒ± al
                    let fileURLs = try fileManager.contentsOfDirectory(atPath: path)
                    
                    // Ses dosyalarƒ±nƒ± filtrele
                    let soundFiles = fileURLs.filter { filePath in
                        return extensions.contains { ext in
                            filePath.hasSuffix(".\(ext)")
                        }
                    }
                    
                    if soundFiles.isEmpty {
                        log("‚ö†Ô∏è \(path) i√ßinde ses dosyasƒ± bulunamadƒ±")
                    } else {
                        log("‚úÖ \(path) i√ßinde bulunan ses dosyalarƒ±: \(soundFiles)")
                        
                        // Dosya detaylarƒ±nƒ± g√∂ster
                        for soundFile in soundFiles {
                            let fullPath = URL(fileURLWithPath: path).appendingPathComponent(soundFile).path
                            do {
                                let attrs = try fileManager.attributesOfItem(atPath: fullPath)
                                let fileSize = attrs[.size] as? UInt64 ?? 0
                                log("üìä '\(soundFile)' - Boyut: \(fileSize) bytes")
                            } catch {
                                logError("'\(soundFile)' √∂zellikleri okunamadƒ±: \(error)")
                            }
                        }
                    }
                } catch {
                    logError("\(path) i√ßeriƒüi okunamadƒ±: \(error)")
                }
            } else {
                log("‚ö†Ô∏è Dizin mevcut deƒüil: \(path)")
            }
        }
        
        // Ana bundle i√ßindeki ses kaynaklarƒ±nƒ± listele
        log("\nÔøΩÔøΩ Bundle kaynaklarƒ±nƒ± doƒürudan kontrol ediyorum:")
        
        // Test edilecek ses dosyalarƒ±
        let testSounds = ["tap", "error", "correct", "completion", "number_tap"]
        
        for soundName in testSounds {
            for ext in extensions {
                if let resourcePath = Bundle.main.path(forResource: soundName, ofType: ext) {
                    log("‚úÖ '\(soundName).\(ext)' bulundu: \(resourcePath)")
                    
                    // Dosya boyutunu kontrol et
                    do {
                        let attrs = try fileManager.attributesOfItem(atPath: resourcePath)
                        let fileSize = attrs[.size] as? UInt64 ?? 0
                        log("üìä '\(soundName).\(ext)' - Boyut: \(fileSize) bytes")
                        
                        // Dosyayƒ± AVAudioPlayer ile a√ßmaya √ßalƒ±≈ü
                        do {
                            let url = URL(fileURLWithPath: resourcePath)
                            let testPlayer = try AVAudioPlayer(contentsOf: url)
                            log("‚úÖ '\(soundName).\(ext)' AVAudioPlayer ile a√ßƒ±labildi - S√ºre: \(testPlayer.duration) sn")
                        } catch {
                            logError("'\(soundName).\(ext)' AVAudioPlayer ile a√ßƒ±lamadƒ±: \(error)")
                        }
                    } catch {
                        logError("'\(soundName).\(ext)' dosya √∂zellikleri okunamadƒ±: \(error)")
                    }
                } else {
                    log("‚ùå '\(soundName).\(ext)' bulunamadƒ±")
                }
            }
        }
    }
    
    /// Ses seviyesini g√ºnceller ve t√ºm oynatƒ±cƒ±lara uygular
    func updateVolumeLevel(_ volume: Double) {
        log("üîä Ses seviyesi g√ºncelleniyor: \(volume)")
        defaultVolume = volume
        
        // T√ºm oynatƒ±cƒ±lara yeni ses seviyesini uygula
        numberInputPlayer?.volume = Float(defaultVolume)
        errorPlayer?.volume = Float(defaultVolume)
        correctPlayer?.volume = Float(defaultVolume)
        completionPlayer?.volume = Float(defaultVolume)
        navigationPlayer?.volume = Float(defaultVolume)
        
        // NOT: Artƒ±k ses seviyesi deƒüi≈ütiƒüinde oynatƒ±cƒ±larƒ± sƒ±fƒ±rlamƒ±yoruz
        // Bu ≈üekilde kafa karƒ±≈üƒ±klƒ±ƒüƒ± ve yanlƒ±≈ü sesler √ßalƒ±nmasƒ± √∂nlenmi≈ü olacak
        
        // Ses deƒüi≈ütiƒüinde bildir
        NotificationCenter.default.post(name: NSNotification.Name("SoundVolumeChangedNotification"), object: nil)
        
        // Ses efekti √ßal (d√º≈ü√ºk seviyede)
        playVolumeChangeIndicator()
    }
    
    /// Ses seviyesini sessizce g√ºnceller - test sesi √ßalmadan (kaydƒ±rƒ±cƒ± hareketi i√ßin)
    func updateVolumeLevelQuietly(_ volume: Double) {
        log("üîä Ses seviyesi sessizce g√ºncelleniyor: \(volume)")
        defaultVolume = volume
        
        // T√ºm oynatƒ±cƒ±lara yeni ses seviyesini uygula
        numberInputPlayer?.volume = Float(defaultVolume)
        errorPlayer?.volume = Float(defaultVolume)
        correctPlayer?.volume = Float(defaultVolume)
        completionPlayer?.volume = Float(defaultVolume)
        navigationPlayer?.volume = Float(defaultVolume)
        
        // Bildirim g√∂nder ama ses √ßalma
        NotificationCenter.default.post(name: NSNotification.Name("SoundVolumeChangedNotification"), object: nil)
    }
    
    /// Ses seviyesi deƒüi≈ütiƒüini g√∂stermek i√ßin kƒ±sa bir ses √ßalar
    private func playVolumeChangeIndicator() {
        guard canPlaySound() else { return }
        
        // Sistem sesi DEVRE DI≈ûI - iOS sistem sesleri sorunlarƒ±nƒ± engellemek i√ßin
        /*
        // Kƒ±sa ve hafif bir sistem tƒ±k sesi √ßal
        if defaultVolume > 0.0 {
            // Ses seviyesine g√∂re farklƒ± sesler
            if defaultVolume < 0.3 {
                AudioServicesPlaySystemSound(1100) // Daha hafif
            } else if defaultVolume < 0.6 {
                AudioServicesPlaySystemSound(1104) // Orta seviye
            } else {
                AudioServicesPlaySystemSound(1103) // Daha g√º√ßl√º
            }
        }
        */
        
        // Kendi ses dosyalarƒ±mƒ±zƒ± kullan
        if defaultVolume > 0.0 {
            // Ses i√ßin tap.wav sesini kullan (number_tap deƒüil)
            log("üîä Ses seviyesi deƒüi≈üikliƒüi i√ßin tap sesi √ßalƒ±nƒ±yor")
            
            if let player = loadSound(named: "tap", ofType: "wav") {
                player.volume = Float(defaultVolume)
                player.play()
            } else {
                logError("tap.wav y√ºklenemedi, ses √ßalƒ±namadƒ±")
            }
        }
    }
    
    /// Ses ayarlarƒ±nƒ± g√ºnceller
    func updateSoundSettings(enabled: Bool) {
        log("üîä Ses ayarlarƒ± g√ºncelleniyor: \(enabled ? "A√ßƒ±k" : "Kapalƒ±")")
        enableSoundEffects = enabled
        
        // Ses ayarƒ± deƒüi≈ütiƒüinde oynatƒ±cƒ±larƒ± sƒ±fƒ±rla
        if enabled {
            resetAudioPlayers()
        }
    }
    
    // Ge√ßici √ß√∂z√ºm - system sound olarak bir test sesi √ßal
    func playBasicTestSound() {
        log("üîä Temel ses testi √ßalƒ±nƒ±yor...")
        guard canPlaySound() else { 
            log("‚ùå Ses ayarlarƒ± kapalƒ± olduƒüu i√ßin test sesi √ßalƒ±namƒ±yor")
            return 
        }
        
        // Ses seviyesine g√∂re test sesleri
        if defaultVolume <= 0.0 {
            log("‚ùå Ses seviyesi 0 olduƒüu i√ßin test sesi √ßalƒ±namƒ±yor")
            return
        }
        
        // Test i√ßin birka√ß farklƒ± ses √ßalarak kullanƒ±cƒ±ya deneyim saƒüla
        DispatchQueue.global().async {
            // √ñnce tap sesi √ßal (number_tap yerine)
            if let player = self.loadSound(named: "tap", ofType: "wav") {
                player.volume = Float(self.defaultVolume)
                player.play()
                Thread.sleep(forTimeInterval: 0.3)
            }
            
            if let player = self.loadSound(named: "correct", ofType: "mp3") ?? self.loadSound(named: "correct", ofType: "wav") {
                player.volume = Float(self.defaultVolume)
                player.play()
                Thread.sleep(forTimeInterval: 1.0)
            } else {
                // Doƒüru sesi y√ºklenemezse alternatif olarak kullan
                if let player = self.loadSound(named: "tap", ofType: "wav") {
                    player.volume = Float(self.defaultVolume)
                    player.play()
                    Thread.sleep(forTimeInterval: 0.5)
                }
            }
            
            // Son olarak hata sesi
            Thread.sleep(forTimeInterval: 0.2)
            if let player = self.loadSound(named: "error", ofType: "wav") {
                player.volume = Float(self.defaultVolume)
                player.play()
                Thread.sleep(forTimeInterval: 0.5)
            } else {
                // Hata sesi y√ºklenemezse alternatif olarak kullan
                if let player = self.loadSound(named: "tap", ofType: "wav") {
                    player.volume = Float(self.defaultVolume)
                    player.play()
                    Thread.sleep(forTimeInterval: 0.5)
                }
            }
        }
        
        log("‚úÖ Test sesi √ßalƒ±ndƒ±")
    }
    
    /// Kullanƒ±cƒ± ses ayarlarƒ±nƒ± kontrol eder
    private func canPlaySound() -> Bool {
        return enableSoundEffects
    }
    
    /// Sayƒ± girildiƒüinde √ßalan ses
    func playNumberInputSound() {
        log("üéµ playNumberInputSound √ßaƒürƒ±ldƒ±")
        guard canPlaySound() else { return }
        
        // Sistem sesi DEVRE DI≈ûI - √ßift ses sorununu √ß√∂zmek i√ßin
        // AudioServicesPlaySystemSound(1104)
        
        // Klasik y√∂ntem - kendi ses dosyamƒ±zƒ± kullanalƒ±m
        if numberInputPlayer == nil {
            numberInputPlayer = loadSound(named: "number_tap", ofType: "wav")
            
            // Y√ºkleme ba≈üarƒ±sƒ±z olursa log tut
            if numberInputPlayer == nil {
                log("‚ùå number_tap.wav y√ºklenemedi, alternatif ses √ßalƒ±namayacak")
            }
        }
        
        guard let player = numberInputPlayer else { 
            log("‚ùå Number input player nil olduƒüu i√ßin ses √ßalƒ±namƒ±yor")
            return 
        }
        
        // ƒ∞smi ve formatƒ± log'la
        log("‚úÖ playNumberInputSound: \(player.url?.lastPathComponent ?? "bilinmeyen")")
        
        if player.isPlaying { player.stop() }
        player.currentTime = 0
        player.volume = Float(defaultVolume)
        player.play()
    }
    
    /// Hatalƒ± bir hamle yapƒ±ldƒ±ƒüƒ±nda √ßalan ses
    func playErrorSound() {
        log("üéµ playErrorSound √ßaƒürƒ±ldƒ±")
        guard canPlaySound() else { return }
        
        // System sound DEVRE DI≈ûI
        // AudioServicesPlaySystemSound(1521) // Standart hata sesi
        
        // Klasik y√∂ntem
        if errorPlayer == nil {
            errorPlayer = loadSound(named: "error", ofType: "wav") ?? loadSound(named: "error", ofType: "mp3")
        }
        
        guard let player = errorPlayer else { return }
        
        if player.isPlaying { player.stop() }
        player.currentTime = 0
        player.volume = Float(defaultVolume)
        player.play()
    }
    
    /// Doƒüru bir hamle yapƒ±ldƒ±ƒüƒ±nda √ßalan ses
    func playCorrectSound() {
        log("üéµ playCorrectSound √ßaƒürƒ±ldƒ±")
        guard canPlaySound() else { return }
        
        // System sound DEVRE DI≈ûI
        // AudioServicesPlaySystemSound(1519) // Standart ba≈üarƒ± sesi
        
        // Klasik y√∂ntem
        if correctPlayer == nil {
            correctPlayer = loadSound(named: "correct", ofType: "wav") ?? loadSound(named: "correct", ofType: "mp3")
        }
        
        guard let player = correctPlayer else { return }
        
        if player.isPlaying { player.stop() }
        player.currentTime = 0
        player.volume = Float(defaultVolume)
        player.play()
    }
    
    /// Oyun ba≈üarƒ±yla tamamlandƒ±ƒüƒ±nda √ßalan ses
    func playCompletionSound() {
        guard canPlaySound() else { return }
        
        // System sound DEVRE DI≈ûI
        // AudioServicesPlaySystemSound(1103) // Posta sesi
        
        // Klasik y√∂ntem
        if completionPlayer == nil {
            completionPlayer = loadSound(named: "completion", ofType: "wav") ?? loadSound(named: "completion", ofType: "mp3")
        }
        
        guard let player = completionPlayer else { return }
        
        if player.isPlaying { player.stop() }
        player.currentTime = 0
        player.volume = Float(defaultVolume)
        player.play()
    }
    
    /// Men√º ve gezinme sesi
    func playNavigationSound() {
        log("üéµ playNavigationSound √ßaƒürƒ±ldƒ±")
        guard canPlaySound() else { return }
        
        // T√ºm sistem sesleri devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±
        // Sadece kendi ses dosyamƒ±zƒ± kullan
        
        // Klasik y√∂ntem - kendi ses dosyamƒ±zƒ± kullanalƒ±m
        if navigationPlayer == nil {
            log("‚ö†Ô∏è Navigation player olu≈üturuluyor - doƒürudan tap.wav kullanƒ±lacak")
            // Burada doƒürudan "tap" dosyasƒ±nƒ± kullan, alternatif aramasƒ± yapma
            navigationPlayer = loadSound(named: "tap", ofType: "wav")
            
            // Y√ºkleme ba≈üarƒ±sƒ±z olursa log tut
            if navigationPlayer == nil {
                log("‚ùå tap.wav y√ºklenemedi, ses √ßalƒ±namayacak")
            }
        }
        
        guard let player = navigationPlayer else { 
            log("‚ùå Navigation player nil olduƒüu i√ßin ses √ßalƒ±namƒ±yor")
            return 
        }
        
        // ƒ∞smi ve formatƒ± log'la
        log("‚úÖ playNavigationSound: \(player.url?.lastPathComponent ?? "bilinmeyen")")
        
        if player.isPlaying { player.stop() }
        player.currentTime = 0
        player.volume = Float(defaultVolume)
        player.play()
    }
    
    // Sesle ilgili eylemleri daha basitle≈ütirmek i√ßin bu fonksiyonu kullan
    func executeSound(_ action: SoundAction) {
        switch action {
        case .tap:
            // TAP i√ßin √∂zel bir print ekleyerek tam olarak ne √ßaƒürƒ±ldƒ±ƒüƒ±nƒ± g√∂relim
            log("üîç executeSound(.tap) √ßaƒürƒ±ldƒ± -> doƒürudan playNavigationSound √ßaƒürƒ±lƒ±yor")
            playNavigationSound()
        case .numberInput:
            // NUMBER_INPUT i√ßin √∂zel bir print ekleyerek ne √ßaƒürƒ±ldƒ±ƒüƒ±nƒ± g√∂relim
            log("üîç executeSound(.numberInput) √ßaƒürƒ±ldƒ± -> playNumberInputSound √ßaƒürƒ±lƒ±yor")
            playNumberInputSound()
        case .correct:
            playCorrectSound()
        case .error:
            playErrorSound()
        case .completion:
            playCompletionSound()
        case .vibrate:
            // Titre≈üim √∂zelliƒüini koru, kullanƒ±cƒ±nƒ±n dokunsal geri bildirimi hissetmesi √∂nemli
            if UIDevice.current.userInterfaceIdiom == .phone {
                AudioServicesPlaySystemSound(kSystemSoundID_Vibrate)
            }
        case .test:
            playBasicTestSound()
        case .erase:
            playEraseSound()
        }
    }
    
    // Ses eylemlerini enum olarak tanƒ±mla
    enum SoundAction {
        case tap           // Men√º ve navigasyon sesleri
        case numberInput   // Sayƒ± giri≈üi
        case correct       // Doƒüru hamle 
        case error         // Yanlƒ±≈ü hamle
        case completion    // Oyunu bitirme
        case vibrate       // Titre≈üim
        case test          // Test sesi
        case erase         // Silme sesi
    }
    
    /// Silme tu≈üu i√ßin ses
    func playEraseSound() {
        log("ÔøΩÔøΩ playEraseSound √ßaƒürƒ±ldƒ±")
        guard canPlaySound() else { return }
        
        // Erase ses dosyasƒ±nƒ± √ßal - √∂nceden y√ºklenmi≈ü oynatƒ±cƒ±yƒ± kullan
        if erasePlayer == nil {
            erasePlayer = loadSound(named: "erase", ofType: "wav")
            if erasePlayer == nil {
                erasePlayer = loadSound(named: "tap", ofType: "wav")
            }
        }
        
        guard let player = erasePlayer else { 
            log("‚ùå Erase player nil olduƒüu i√ßin ses √ßalƒ±namƒ±yor")
            return 
        }
        
        // Mevcut oynatma durumunu kontrol et ve reset
        if player.isPlaying { player.stop() }
        player.currentTime = 0
        player.volume = Float(defaultVolume)
        
        // Asenkron olarak deƒüil, direkt burada √ßal
        player.play()
        
        // Log √ßƒ±ktƒ±sƒ±
        log("‚úÖ playEraseSound: \(player.url?.lastPathComponent ?? "bilinmeyen")")
    }
    
    // Ses seviyesi deƒüi≈ütiƒüinde √ßaƒürƒ±lan fonksiyon
    @objc private func handleVolumeChange(notification: Notification) {
        log("üîä Ses seviyesi deƒüi≈üikliƒüi bildirimi alƒ±ndƒ±")
        // Ses seviyesi deƒüi≈ütiƒüinde gerekli ayarlamalarƒ± yap
        // T√ºm aktif ses oynatƒ±cƒ±larƒ±nƒ±n ses seviyesini g√ºncelle
        numberInputPlayer?.volume = Float(defaultVolume)
        errorPlayer?.volume = Float(defaultVolume)
        correctPlayer?.volume = Float(defaultVolume)
        completionPlayer?.volume = Float(defaultVolume)
        navigationPlayer?.volume = Float(defaultVolume)
        erasePlayer?.volume = Float(defaultVolume)
    }
    
    // MARK: - Log Yardƒ±mcƒ± Metotlarƒ±
    
    /// Loglama ayarƒ±nƒ±n a√ßƒ±lƒ±p/kapatƒ±lmasƒ± i√ßin
    func toggleLogging(_ enabled: Bool) {
        isLoggingEnabled = enabled
        log("Loglama \(enabled ? "a√ßƒ±ldƒ±" : "kapatƒ±ldƒ±")")
    }
    
    /// Basit log fonksiyonu
    private func log(_ message: String) {
        guard isLoggingEnabled else { return }
        print("üîä SoundManager: \(message)")
    }
    
    /// Hata log fonksiyonu - her zaman g√∂sterilir
    private func logError(_ message: String) {
        print("‚ùå SoundManager Hatasƒ±: \(message)")
    }
} 
